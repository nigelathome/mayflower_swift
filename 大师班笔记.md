总体流程是.m/.h/.cpp -> 预编译：词法检查语法检查 -> 静态库 编译 -> 形成Mach-O文件，可执行文件，证书等打包ipa -> dyld连接器 链接动态库，将Mach-O信息载入内存，初始化等 -> 程序执行 main()

静态链接的问题：会编译成多份，对内存和性能的消耗
动态库好处：编译链接的时候不会加入，动态库会以一份实例的形式，在程序被载入的时候才把动态库加载进内存。app的大小大大减少 。常用的动态库有：jspatch\libobjc\libdispatch\libsystem\foundation、coreFoundation\UIKit\
dyld链接器，主动进行链接主程序和动态库

1、dyld是系统连接器，用于运行时程序执行。主要函数有：
* dyld_start()
* dyld::main()
* dyld::initMainExcutable
* libdispatch_system
* objc_init（）

2、objc_init()函数做的事情有：
* 初始化环境变量
* 静态变量初始化
* runtime初始化
* 缓存初始化
* map_images、load_images（写入注册函数）read_image()

runtime的初始化：内存中创建class表
lockupimp()
Mach-O记录的是地址和函数名字
map_image是地址和函数的映射

3、read_image()
* 将mach-O的类添加到class表中
* 通过class list拿到类列表进行遍历、对非懒加载类进行实现：类的协议、分类、selector
* 对非懒加载类进行实现通过realiszedClassWithoutSwift（）

4、realiszedClassWithoutSwift() 内存中生成一个类的框架结构，如LGPerson内存中他的isa、superclass、属性、方法等
* Mach-0中取class地址中的data，data是存到内存中的数据，这个存储过程在前面流程已经完成
* 处理类的元类和父类
* 构造继承链信息
* 构造isa
* 方法化类 methodizeClass()

5、methodizeClass（）
* 对class的method list进行排序，应用于后续的方法的二分查找，排序的key是sel的地址，不是sel的名字。sel地址是会变化的，例如动态库增加了，sel地址就变了
* property list排序、协议排序、元类处理等
* 处理分类attachToClass（）

懒加载类，没有实现+load方法。数据加载推迟到第一次执行alloc消息，然后触发objc_msgSend, 最后通过realiszedClassWithoutSwift（）实现加载
非懒加载类，实现了+load方法。map_images的时候加载所有数据，通过realiszedClassWithoutSwift（）加载。在main执行之前。所以从性能的角度，懒加载类优化的main执行前的流程，也就是程序启动更快了，也就是一种APP启动优化 
只要有一个分类有load方法，所有的分类都不是懒加载类

6、分类中属性没有setter和getter方法，只能通过runtime的关联对象，分类本质是一个category_t的结构体，有name、cls、实例方法列表、类方法列表、protocols、属性列表。但属性没有setter和getter方法

7、attachToClass（）
* 将方法列表method_list加入到对应的cls类中，或者加入元类中
* 将协议列表protocol_list加入到对应的cls类中
* 将属性列表property_list加入到对应的cls类中

8、类的加载时机
* 主类load   分类load   load_image 加载数据
* 主类    分类load  迫使类成为非懒加载类提前加载数据
* 主类   分类 都是懒加载则在消息第一次调用的时候加载数据 
* 主类load 分类 load_image 加载数据
结论是：在分类中写load方法会增加很多构造方法用于类的构造，要尽量不必要的+load方法

9、分类和类扩展的区别
* 分类专门用于方法扩展，不能给类添加属性，即使添加了也不会生成成员变量+setter/getter方法（setter/getter方法的声明是有的）；要想添加属性需要使用runtime关联对象实现
* 类扩展是特殊的分类，可以添加属性和方法，都是私有的只能在类中进行访问，编译期而不是运行时确定

10、类扩展
* 属性会产生setter/getter方法，是对主类的扩展
* 添加了+load方法，主类就成了非懒加载类，主类就不需要加+load方法了，因为类扩展本身就是同一个
* 编译期就确定

11、setter/getter实现原理
* 底层实现方法reallySetProperty(self , newValue, offset, atomic, copy, mutableCopy) 
* 对象/类对象地址 + 偏移量计算出一个slot，slot就是要更新的属性的地址
* 对newValue进行处理：如果是copy/mutableCopy/retain -> 分别调用copyWithZone/mutableCopyWithZone/objc_retain 处理newValue
* newValue赋值给原属性，也就是slot 
* 如果是atomic的，通过加spinLock的方式赋值给slot；如果是nonatomic的直接赋值
* getter方法通过slot拿到属性，然后*slot就可以拿到值

10、关联对象的底层原理
