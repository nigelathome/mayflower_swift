总体流程是.m/.h/.cpp -> 预编译：词法检查语法检查 -> 静态库 编译 -> 形成Mach-O文件，可执行文件，证书等打包ipa -> dyld连接器 链接动态库，将Mach-O信息载入内存，初始化等 -> 程序执行 main()

1、dyld是系统连接器，用于运行时程序执行。主要函数有：
* dyld_start()
* dyld::main()
* dyld::initMainExcutable
* libdispatch_system
* objc_init（）

2、objc_init()函数做的事情有：
* 初始化环境变量
* 静态变量初始化
* runtime初始化
* 缓存初始化
* map_images、load_images（写入注册函数）read_image()

runtime的初始化：内存中创建class表
lockupimp()
Mach-O记录的是地址和函数名字
map_image是地址和函数的映射

3、read_image()
* 将mach-O的类添加到class表中
* 通过class list拿到类列表进行遍历、对非懒加载类进行实现：类的协议、分类、selector
* 对非懒加载类进行实现通过realiszedClassWithoutSwift（）

4、realiszedClassWithoutSwift() 内存中生成一个类的框架结构，如LGPerson内存中他的isa、superclass、属性、方法等
* Mach-0中取class地址中的data，data是存到内存中的数据，这个存储过程在前面流程已经完成
* 处理类的元类和父类
* 构造继承链信息
* 构造isa
* 方法化类 methodizeClass()

5、methodizeClass（）
* 对class的method list进行排序，应用于后续的方法的二分查找
* property list排序、协议排序、元类处理等
* 处理分类attachToClass（）

懒加载类，没有实现+load方法。数据加载推迟到第一次执行alloc消息，然后触发objc_msgSend, 最后通过realiszedClassWithoutSwift（）实现加载
非懒加载类，实现了+load方法。map_images的时候加载所有数据，通过realiszedClassWithoutSwift（）加载。在main执行之前。所以从性能的角度，懒加载类优化的main执行前的流程，也就是程序启动更快了，也就是一种APP启动优化 
只要有一个分类有load方法，所有的分类都不是懒加载类

6、分类中属性没有setter和getter方法，只能通过runtime的关联对象，分类本质是一个category_t的结构体，有name、cls、实例方法列表、类方法列表、protocols、属性列表。但属性没有setter和getter方法

7、attachToClass（）
* 将方法列表method_list加入到对应的cls类中，或者加入元类中
* 将协议列表protocol_list加入到对应的cls类中
* 将属性列表property_list加入到对应的cls类中

8、类的加载时机
* 主类load   分类load   load_image 加载数据
* 主类    分类load  迫使类成为非懒加载类提前加载数据
* 主类   分类 都是懒加载则在消息第一次调用的时候加载数据 
* 主类load 分类 load_image 加载数据
